{"ast":null,"code":"var _jsxFileName = \"F:\\\\code\\\\SudoQubs\\\\src\\\\components\\\\4-Four.jsx\",\n    _s = $RefreshSig$();\n\nimport { useState } from 'react';\nimport '../styles/0-zero.css';\nimport { qubs, update, cols, boxs, restore, poss, detectdifficulty, megasolution, howmanyQubs, pointerMistakes, rows_cols_to_squares, getBoxFromQ, boxs_to_squares } from '../functions/2-Estructures.js';\nimport { solution } from '../functions/0-Unrepeatable.js';\nimport { type } from '@testing-library/user-event/dist/type';\nimport RepeatedIndexes from '../functions/RepeatedIndexes';\nimport Squares from '../functions/Squares';\nimport ChangeColor from '../functions/ChangeColor';\nimport ChangeState from '../functions/ChangeState'; // const { qubs, update, cols, boxs, restore } = require('../functions/2-Estructures.js');\n// const { solution } = require('../functions/0-Unrepeatable.js');\n// const { create } = require('../functions/3-Creator.js')\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Four(_ref) {\n  _s();\n\n  let {\n    unity,\n    rows,\n    loyalindex,\n    carga,\n    sendFill,\n    sendRepsRows,\n    sendRepsCols,\n    sendRepsBoxs,\n    sending\n  } = _ref;\n  //ESTADOS LOCALES\n  let [filas, setFilas] = useState(rows);\n  let [reps, setReps] = useState([]);\n  let [repsC, setRepsC] = useState([]);\n  let [repsB, setRepsB] = useState([]); // let [noreps, setNoreps]= useState([ ])\n\n  let [input, setInput] = useState({}); //Estado que maneja cada input del sudoku\n  //FUNCIONES\n  //Función que se ejecuta por cada ingreso de cualquier caracter en cualquier casilla:\n\n  function changeEach(e) {\n    var val = e.target.value;\n    console.log(\"unity, typeof loyalindex, val, typeof val\", unity, loyalindex, val, typeof val);\n    console.log(isNaN(val)); //_______________________________________________________\n    //LÍNEA QUE NO ADMITE UNA CADENA DE LARGO MAYOR A 1\n\n    if (val.length > 1) return setInput({ ...input,\n      [loyalindex]: val[0]\n    }); //MÓDULO QUE SOLO DEJA ENTRAR NÚMEROS ENTRE EL 1 AL 9\n\n    if (isNaN(val) || val === 0 || val === '0') return setInput({ ...input,\n      [loyalindex]: ''\n    });\n    setInput({ ...input,\n      [loyalindex]: val\n    }); // ______________________________________________________\n\n    if (val === '') unity = 0; //Si se borra un numero va a llegar un string vacío\n\n    if (val !== '') unity = parseInt(val);\n    qubs[loyalindex] = unity;\n    setFilas(update(loyalindex)); //CON ESTE update(q) ACTUALIZO TODAS LAS ENTIDADES (COLUMNAS, FILAS y CAJAS)\n\n    sendFill(howmanyQubs(rows)); //ESTE ES PARA CONTAR CUÁNTOS CASILLEROS ESTÁN LLENOS y CUÁNTOS VACÍOS\n\n    let repsRows = pointerMistakes('rows', megasolution(2), 2); //DETECTOR DE REPETICIONES EN LAS FILAS\n\n    let repsCols = pointerMistakes('cols', megasolution(2), 2); //PARA DETECTAR REPETICIONES EN LAS COLUMNAS\n\n    let repsBoxs = pointerMistakes('boxs', megasolution(2), 2); //PARA DETECTAR REPETICIONES EN LAS CAJAS\n    // console.log(repsRows, repsCols, repsBoxs)\n    //PARTE 'A' ROWS\n\n    let indexs = [];\n    indexs = RepeatedIndexes(indexs, repsRows); // for(let ab= 0; ab< repsRows.length; ab++){\n    //     indexs[ab]= []\n    //     indexs[ab].push(repsRows[ab]['indice'])\n    //     for(let ac= 0; ac< repsRows[ab]['subindice'].length; ac++){\n    //         // console.log(repsRows[ab]['subindice'][ac]) //ÍNDICES\n    //         indexs[ab].push(repsRows[ab]['subindice'][ac]['reps'])\n    //     }\n    // }\n    //PARTE 'A' COLS\n\n    let indexsC = [];\n    indexsC = RepeatedIndexes(indexsC, repsCols);\n    let indexsB = [];\n    indexsB = RepeatedIndexes(indexsB, repsBoxs); // for(let ab= 0; ab< repsCols.length; ab++){\n    //     indexsC[ab]= []\n    //     indexsC[ab].push(repsCols[ab]['indice'])\n    //     for(let ac= 0; ac< repsCols[ab]['subindice'].length; ac++){\n    //         // console.log(repsCols[ab]['subindice'][ac]) //ÍNDICES\n    //         indexsC[ab].push(repsCols[ab]['subindice'][ac]['reps'])\n    //     }\n    // }\n    // console.log( indexs, indexsC)\n    //PARTE 'B' ROWS\n\n    let squares = Squares(indexs, 'rows', rows_cols_to_squares); // let squares= []\n    // for (let i = 0; i < indexs.length; i++) {\n    //     let first= indexs[i][0]\n    //     console.log('first', first)\n    //     for (let u=1;u<indexs[i].length;u++) {\n    //         let second1= indexs[i][u][0]\n    //         let second2= indexs[i][u][1]\n    //         console.log('second', second1, second2)\n    //         let sq1= rows_cols_to_squares(first, second1, 'rows')\n    //         let sq2= rows_cols_to_squares(first, second2, 'rows')\n    //         squares.push(sq1, sq2)\n    //     }\n    // }\n    // console.log(squares)\n    //PARTE 'B' COLS \n\n    let squaresC = Squares(indexsC, 'cols', rows_cols_to_squares);\n    let squaresB = Squares(indexsB, 'boxs', boxs_to_squares); // let squaresC= []\n    // for (let i = 0; i < indexsC.length; i++) {\n    //     let first= indexsC[i][0]\n    //     console.log('first', first)\n    //     for (let u=1;u<indexsC[i].length;u++) {\n    //         let second1= indexsC[i][u][0]\n    //         let second2= indexsC[i][u][1]\n    //         console.log('second', second1, second2)\n    //         let sq1= rows_cols_to_squares(first, second1, 'cols')\n    //         let sq2= rows_cols_to_squares(first, second2, 'cols')\n    //         squaresC.push(sq1, sq2)\n    //     }\n    // }\n    // console.log(squaresC)\n    //HASTA ACÄ TODO 10 PUNTOS\n    //ANTES HAY QUE HACER LA COMPARACIÓN ENTRE useState() Y pointerMistakes()\n    //EN BASE A ESO, MANDAR A PINTAR Y MANDAR A DESPINTAR\n    // 'C' ROWS\n\n    ChangeColor(squares); // for(let gamma= 0; gamma<squares.length; gamma++){\n    //     // console.log(squares[gamma][0])\n    //     // console.log(squares[gamma][1])\n    //     document.getElementsByTagName('input')[squares[gamma]].style.color= 'red'\n    //     document.getElementsByTagName('input')[squares[gamma]].style.color= 'red'\n    // }\n    // 'C' COLS\n\n    ChangeColor(squaresC);\n    ChangeColor(squaresB); // for(let gamma= 0; gamma<squaresC.length; gamma++){\n    //     // console.log(squares[gamma][0])\n    //     // console.log(squares[gamma][1])\n    //     document.getElementsByTagName('input')[squaresC[gamma]].style.color= 'red'\n    //     document.getElementsByTagName('input')[squaresC[gamma]].style.color= 'red'\n    // }\n    //Y PUDIERA SER QUE HASTA ACÁ, PERFECTO TAMBIÉN\n    //LO QUE VIENE AHORA SERÍA LO RECIÉN MENCIONADO SOBRE COMPARAR PARA DESPINTAR\n    //TRAEME useState() que contiene lo de la anterior vuelta, (1)\n    //SI ES DISTINTO DE VACÍO, LO ANALIZAMOS. (2)\n    //Recordar que useState() siempre va a guardar todos los datos que le mandemos.\n    //Si nada los borra, quedan ahí. Entonces:\n    //SI useState() PRESENTA DATOS DE pointerMistakes(), IGNORAR ESTOS (3)\n    //SI PRESENTA DATOS QUE pointerMistakes() NO REGISTRÓ, DESPINTARLOS (4)\n    //Nota: al mencionar pointerMistakes(), hacemos referencia al post-producto: es decir los squares que están dentro del Array squares\n    // PARTE 'D' ROWS\n\n    ChangeState(reps, squares, setReps); // let noReps= []\n    // // if(reps.length){ //(1), (2)\n    //     for(let delta=0;delta<reps.length;delta++){\n    //         let test=[]\n    //         let e= 0\n    //         for(let eco=0;eco<squares.length;eco++){\n    //             // if(eco===delta)continue\n    //             // if(reps[delta][0]===squares[eco][0]){\n    //             //     console.log('continue en 0')\n    //             // }\n    //             // if(reps[delta][1]===squares[eco][1]){\n    //             //     console.log('continue en 1')\n    //             // }\n    //             if(reps[delta]===squares[eco]){\n    //                 // console.log(reps[delta, squares[eco]], ' iguales')\n    //                 test.push(1)\n    //             }\n    //             e= eco\n    //             // if(!test.length && e===squares.length-1){\n    //             //     noReps.push(reps[delta])\n    //             // }\n    //         }\n    //         if(!test.length){\n    //             noReps.push(reps[delta])\n    //         }\n    //     }\n    // // }\n    // console.log(reps, squares, noReps)\n    // for(let ohmega=0; ohmega< noReps.length; ohmega++){\n    //     let color= noReps[ohmega] % 2===0? 'orange':'orangered'\n    //     console.log(noReps[ohmega], color)\n    //     document.getElementsByTagName('input')[noReps[ohmega]].style.color= color\n    // }\n    // setReps(squares)\n    // PARTE 'D' COLS\n\n    ChangeState(repsC, squaresC, setRepsC);\n    ChangeState(repsB, squaresB, setRepsB); // let noRepsC= []\n    // // if(reps.length){ //(1), (2)\n    //     for(let delta=0;delta<repsC.length;delta++){\n    //         let test=[]\n    //         let e= 0\n    //         for(let eco=0;eco<squaresC.length;eco++){\n    //             // if(eco===delta)continue\n    //             // if(reps[delta][0]===squares[eco][0]){\n    //             //     console.log('continue en 0')\n    //             // }\n    //             // if(reps[delta][1]===squares[eco][1]){\n    //             //     console.log('continue en 1')\n    //             // }\n    //             if(repsC[delta]===squaresC[eco]){\n    //                 // console.log(reps[delta, squares[eco]], ' iguales')\n    //                 test.push(1)\n    //             }\n    //             e= eco\n    //             // if(!test.length && e===squares.length-1){\n    //             //     noReps.push(reps[delta])\n    //             // }\n    //         }\n    //         if(!test.length){\n    //             noRepsC.push(repsC[delta])\n    //         }\n    //     }\n    // // }\n    // console.log(repsC, squaresC, noRepsC)\n    // for(let ohmega=0; ohmega< noRepsC.length; ohmega++){\n    //     let color= noRepsC[ohmega] % 2===0? 'orange':'orangered'\n    //     console.log(noRepsC[ohmega], color)\n    //     document.getElementsByTagName('input')[noRepsC[ohmega]].style.color= color\n    // }\n    // setRepsC(squaresC)\n  } //CONDICIONALES \n  //Cuando el botón Cargar se pulsa, carga es === true, y el sudoku se llena con los datos del algoritmo generador\n\n\n  if (carga) {\n    if (unity !== 0) {\n      document.getElementsByTagName(\"input\")[loyalindex].value = unity;\n    }\n\n    if (typeof unity !== 'number' || isNaN(unity)) {\n      // console.log(unity, typeof unity, loyalindex)\n      document.getElementsByTagName(\"input\")[loyalindex].value = 0;\n    }\n\n    if (unity === 0) {\n      document.getElementsByTagName(\"input\")[loyalindex].value = '';\n    }\n  } //UN DETALLE ESTÉTICO PARA CAMBIAR EL COLOR DE FONDO DE LAS CAJAS (VER EN EL BROWSER)\n\n\n  let box_Array = getBoxFromQ(loyalindex);\n  let back = box_Array[0] % 2 === 0 ? 'black' : 'rgb(30,20,10)';\n\n  if (loyalindex === 80) {}\n\n  return /*#__PURE__*/_jsxDEV(\"span\", {\n    children: /*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"text\" // No hace falta que sea type = 'number', con el Estado Local lo solucionamos\n      ,\n      value: input[loyalindex] // Esto es clave para que la última palabra la tenga el Estado Local con sus validaciones de si es un número entre 1 y 9\n      ,\n      className: loyalindex % 2 === 0 ? 'unity' : 'impar' // Define el color de los números (ver en el browser)\n      ,\n      style: {\n        backgroundColor: back\n      } // Define el color de fondo de las cajas\n      ,\n      onChange: e => changeEach(e)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 270,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 269,\n    columnNumber: 13\n  }, this);\n}\n\n_s(Four, \"y0SCnw34QSxGL5FpqOTMyo0v5TU=\");\n\n_c = Four;\n\nvar _c;\n\n$RefreshReg$(_c, \"Four\");","map":{"version":3,"names":["useState","qubs","update","cols","boxs","restore","poss","detectdifficulty","megasolution","howmanyQubs","pointerMistakes","rows_cols_to_squares","getBoxFromQ","boxs_to_squares","solution","type","RepeatedIndexes","Squares","ChangeColor","ChangeState","Four","unity","rows","loyalindex","carga","sendFill","sendRepsRows","sendRepsCols","sendRepsBoxs","sending","filas","setFilas","reps","setReps","repsC","setRepsC","repsB","setRepsB","input","setInput","changeEach","e","val","target","value","console","log","isNaN","length","parseInt","repsRows","repsCols","repsBoxs","indexs","indexsC","indexsB","squares","squaresC","squaresB","document","getElementsByTagName","box_Array","back","backgroundColor"],"sources":["F:/code/SudoQubs/src/components/4-Four.jsx"],"sourcesContent":["import { useState } from 'react';\r\nimport '../styles/0-zero.css';\r\nimport { qubs, update, cols, boxs, restore, poss, detectdifficulty, megasolution, howmanyQubs, pointerMistakes, rows_cols_to_squares, getBoxFromQ, boxs_to_squares } from '../functions/2-Estructures.js';\r\nimport { solution } from '../functions/0-Unrepeatable.js';\r\nimport { type } from '@testing-library/user-event/dist/type';\r\nimport RepeatedIndexes from '../functions/RepeatedIndexes';\r\nimport Squares from '../functions/Squares';\r\nimport ChangeColor from '../functions/ChangeColor';\r\nimport ChangeState from '../functions/ChangeState';\r\n\r\n// const { qubs, update, cols, boxs, restore } = require('../functions/2-Estructures.js');\r\n// const { solution } = require('../functions/0-Unrepeatable.js');\r\n// const { create } = require('../functions/3-Creator.js')\r\n\r\n\r\nexport default function Four({unity, rows, loyalindex, carga, sendFill, sendRepsRows, sendRepsCols, sendRepsBoxs, sending}){\r\n\r\n    //ESTADOS LOCALES\r\n    let [filas, setFilas]= useState(rows) \r\n    let [reps, setReps]= useState([])\r\n    let [repsC, setRepsC]= useState([])\r\n    let [repsB, setRepsB]= useState([])\r\n    // let [noreps, setNoreps]= useState([ ])\r\n    let [input, setInput] = useState({ }) //Estado que maneja cada input del sudoku\r\n\r\n\r\n    //FUNCIONES\r\n    //Función que se ejecuta por cada ingreso de cualquier caracter en cualquier casilla:\r\n    function changeEach(e){\r\n\r\n        var val= e.target.value\r\n        console.log(\"unity, typeof loyalindex, val, typeof val\", unity, loyalindex, val, typeof val)\r\n        console.log(isNaN(val))\r\n        \r\n        //_______________________________________________________\r\n        //LÍNEA QUE NO ADMITE UNA CADENA DE LARGO MAYOR A 1\r\n        if(val.length > 1) return setInput({...input, [loyalindex]: val[0]})\r\n        //MÓDULO QUE SOLO DEJA ENTRAR NÚMEROS ENTRE EL 1 AL 9\r\n        if(isNaN(val) || val === 0 || val === '0') return setInput({...input, [loyalindex]: ''})\r\n\r\n        setInput({...input, [loyalindex]: val}) \r\n        // ______________________________________________________\r\n\r\n        if(val==='') unity= 0 //Si se borra un numero va a llegar un string vacío\r\n        if(val!=='') unity= parseInt(val)\r\n\r\n        qubs[loyalindex]= unity\r\n        setFilas(update(loyalindex)) //CON ESTE update(q) ACTUALIZO TODAS LAS ENTIDADES (COLUMNAS, FILAS y CAJAS)\r\n        sendFill(howmanyQubs(rows)) //ESTE ES PARA CONTAR CUÁNTOS CASILLEROS ESTÁN LLENOS y CUÁNTOS VACÍOS\r\n        \r\n        let repsRows=pointerMistakes('rows', megasolution(2), 2) //DETECTOR DE REPETICIONES EN LAS FILAS\r\n        let repsCols=pointerMistakes('cols', megasolution(2), 2) //PARA DETECTAR REPETICIONES EN LAS COLUMNAS\r\n        let repsBoxs=pointerMistakes('boxs', megasolution(2), 2) //PARA DETECTAR REPETICIONES EN LAS CAJAS\r\n\r\n        // console.log(repsRows, repsCols, repsBoxs)\r\n\r\n        //PARTE 'A' ROWS\r\n        let indexs= []\r\n\r\n        indexs= RepeatedIndexes(indexs, repsRows)\r\n\r\n        // for(let ab= 0; ab< repsRows.length; ab++){\r\n        //     indexs[ab]= []\r\n        //     indexs[ab].push(repsRows[ab]['indice'])\r\n        //     for(let ac= 0; ac< repsRows[ab]['subindice'].length; ac++){\r\n        //         // console.log(repsRows[ab]['subindice'][ac]) //ÍNDICES\r\n        //         indexs[ab].push(repsRows[ab]['subindice'][ac]['reps'])\r\n        //     }\r\n        // }\r\n        \r\n        //PARTE 'A' COLS\r\n        \r\n        let indexsC= []\r\n\r\n        indexsC= RepeatedIndexes(indexsC, repsCols)\r\n\r\n        let indexsB= []\r\n\r\n        indexsB= RepeatedIndexes(indexsB, repsBoxs)\r\n\r\n        // for(let ab= 0; ab< repsCols.length; ab++){\r\n        //     indexsC[ab]= []\r\n        //     indexsC[ab].push(repsCols[ab]['indice'])\r\n        //     for(let ac= 0; ac< repsCols[ab]['subindice'].length; ac++){\r\n        //         // console.log(repsCols[ab]['subindice'][ac]) //ÍNDICES\r\n        //         indexsC[ab].push(repsCols[ab]['subindice'][ac]['reps'])\r\n        //     }\r\n        // }\r\n        // console.log( indexs, indexsC)\r\n\r\n        //PARTE 'B' ROWS\r\n        let squares= Squares(indexs, 'rows', rows_cols_to_squares)\r\n\r\n        // let squares= []\r\n        // for (let i = 0; i < indexs.length; i++) {\r\n        //     let first= indexs[i][0]\r\n        //     console.log('first', first)\r\n        //     for (let u=1;u<indexs[i].length;u++) {\r\n        //         let second1= indexs[i][u][0]\r\n        //         let second2= indexs[i][u][1]\r\n        //         console.log('second', second1, second2)\r\n        //         let sq1= rows_cols_to_squares(first, second1, 'rows')\r\n        //         let sq2= rows_cols_to_squares(first, second2, 'rows')\r\n        //         squares.push(sq1, sq2)\r\n        //     }\r\n        // }\r\n        // console.log(squares)\r\n        \r\n        //PARTE 'B' COLS \r\n        let squaresC= Squares(indexsC, 'cols', rows_cols_to_squares)\r\n        \r\n        let squaresB= Squares(indexsB, 'boxs', boxs_to_squares)\r\n\r\n        // let squaresC= []\r\n        // for (let i = 0; i < indexsC.length; i++) {\r\n        //     let first= indexsC[i][0]\r\n        //     console.log('first', first)\r\n        //     for (let u=1;u<indexsC[i].length;u++) {\r\n        //         let second1= indexsC[i][u][0]\r\n        //         let second2= indexsC[i][u][1]\r\n        //         console.log('second', second1, second2)\r\n        //         let sq1= rows_cols_to_squares(first, second1, 'cols')\r\n        //         let sq2= rows_cols_to_squares(first, second2, 'cols')\r\n        //         squaresC.push(sq1, sq2)\r\n        //     }\r\n        // }\r\n        // console.log(squaresC)\r\n\r\n        //HASTA ACÄ TODO 10 PUNTOS\r\n\r\n        //ANTES HAY QUE HACER LA COMPARACIÓN ENTRE useState() Y pointerMistakes()\r\n        //EN BASE A ESO, MANDAR A PINTAR Y MANDAR A DESPINTAR\r\n\r\n        // 'C' ROWS\r\n        ChangeColor(squares)\r\n        // for(let gamma= 0; gamma<squares.length; gamma++){\r\n        //     // console.log(squares[gamma][0])\r\n        //     // console.log(squares[gamma][1])\r\n        //     document.getElementsByTagName('input')[squares[gamma]].style.color= 'red'\r\n        //     document.getElementsByTagName('input')[squares[gamma]].style.color= 'red'\r\n        // }\r\n        // 'C' COLS\r\n        ChangeColor(squaresC)\r\n        ChangeColor(squaresB)\r\n\r\n        // for(let gamma= 0; gamma<squaresC.length; gamma++){\r\n        //     // console.log(squares[gamma][0])\r\n        //     // console.log(squares[gamma][1])\r\n        //     document.getElementsByTagName('input')[squaresC[gamma]].style.color= 'red'\r\n        //     document.getElementsByTagName('input')[squaresC[gamma]].style.color= 'red'\r\n        // }\r\n        //Y PUDIERA SER QUE HASTA ACÁ, PERFECTO TAMBIÉN\r\n\r\n        //LO QUE VIENE AHORA SERÍA LO RECIÉN MENCIONADO SOBRE COMPARAR PARA DESPINTAR\r\n        //TRAEME useState() que contiene lo de la anterior vuelta, (1)\r\n        //SI ES DISTINTO DE VACÍO, LO ANALIZAMOS. (2)\r\n        //Recordar que useState() siempre va a guardar todos los datos que le mandemos.\r\n        //Si nada los borra, quedan ahí. Entonces:\r\n        //SI useState() PRESENTA DATOS DE pointerMistakes(), IGNORAR ESTOS (3)\r\n        //SI PRESENTA DATOS QUE pointerMistakes() NO REGISTRÓ, DESPINTARLOS (4)\r\n\r\n        //Nota: al mencionar pointerMistakes(), hacemos referencia al post-producto: es decir los squares que están dentro del Array squares\r\n\r\n        // PARTE 'D' ROWS\r\n        ChangeState(reps, squares, setReps)\r\n\r\n        // let noReps= []\r\n        // // if(reps.length){ //(1), (2)\r\n        //     for(let delta=0;delta<reps.length;delta++){\r\n        //         let test=[]\r\n        //         let e= 0\r\n        //         for(let eco=0;eco<squares.length;eco++){\r\n        //             // if(eco===delta)continue\r\n        //             // if(reps[delta][0]===squares[eco][0]){\r\n        //             //     console.log('continue en 0')\r\n        //             // }\r\n        //             // if(reps[delta][1]===squares[eco][1]){\r\n        //             //     console.log('continue en 1')\r\n        //             // }\r\n        //             if(reps[delta]===squares[eco]){\r\n        //                 // console.log(reps[delta, squares[eco]], ' iguales')\r\n        //                 test.push(1)\r\n        //             }\r\n        //             e= eco\r\n        //             // if(!test.length && e===squares.length-1){\r\n        //             //     noReps.push(reps[delta])\r\n        //             // }\r\n        //         }\r\n        //         if(!test.length){\r\n        //             noReps.push(reps[delta])\r\n        //         }\r\n        //     }\r\n        // // }\r\n        // console.log(reps, squares, noReps)\r\n        // for(let ohmega=0; ohmega< noReps.length; ohmega++){\r\n        //     let color= noReps[ohmega] % 2===0? 'orange':'orangered'\r\n        //     console.log(noReps[ohmega], color)\r\n        //     document.getElementsByTagName('input')[noReps[ohmega]].style.color= color\r\n        // }\r\n        // setReps(squares)\r\n\r\n        \r\n        // PARTE 'D' COLS\r\n        ChangeState(repsC, squaresC, setRepsC)\r\n\r\n        ChangeState(repsB, squaresB, setRepsB)\r\n\r\n\r\n        // let noRepsC= []\r\n        // // if(reps.length){ //(1), (2)\r\n        //     for(let delta=0;delta<repsC.length;delta++){\r\n        //         let test=[]\r\n        //         let e= 0\r\n        //         for(let eco=0;eco<squaresC.length;eco++){\r\n        //             // if(eco===delta)continue\r\n        //             // if(reps[delta][0]===squares[eco][0]){\r\n        //             //     console.log('continue en 0')\r\n        //             // }\r\n        //             // if(reps[delta][1]===squares[eco][1]){\r\n        //             //     console.log('continue en 1')\r\n        //             // }\r\n        //             if(repsC[delta]===squaresC[eco]){\r\n        //                 // console.log(reps[delta, squares[eco]], ' iguales')\r\n        //                 test.push(1)\r\n        //             }\r\n        //             e= eco\r\n        //             // if(!test.length && e===squares.length-1){\r\n        //             //     noReps.push(reps[delta])\r\n        //             // }\r\n        //         }\r\n        //         if(!test.length){\r\n        //             noRepsC.push(repsC[delta])\r\n        //         }\r\n        //     }\r\n        // // }\r\n        // console.log(repsC, squaresC, noRepsC)\r\n        // for(let ohmega=0; ohmega< noRepsC.length; ohmega++){\r\n        //     let color= noRepsC[ohmega] % 2===0? 'orange':'orangered'\r\n        //     console.log(noRepsC[ohmega], color)\r\n        //     document.getElementsByTagName('input')[noRepsC[ohmega]].style.color= color\r\n        // }\r\n        // setRepsC(squaresC)\r\n\r\n    }\r\n\r\n    //CONDICIONALES \r\n    //Cuando el botón Cargar se pulsa, carga es === true, y el sudoku se llena con los datos del algoritmo generador\r\n    if (carga) {\r\n        if(unity!==0){\r\n            document.getElementsByTagName(\"input\")[loyalindex].value= unity\r\n        }\r\n        if(typeof unity !== 'number' || isNaN(unity)){\r\n            // console.log(unity, typeof unity, loyalindex)\r\n            document.getElementsByTagName(\"input\")[loyalindex].value= 0\r\n        }\r\n        if(unity===0 ){\r\n            document.getElementsByTagName(\"input\")[loyalindex].value= ''\r\n        }\r\n    }\r\n\r\n    //UN DETALLE ESTÉTICO PARA CAMBIAR EL COLOR DE FONDO DE LAS CAJAS (VER EN EL BROWSER)\r\n    let box_Array= getBoxFromQ(loyalindex)\r\n    let back= box_Array[0]%2===0? 'black' : 'rgb(30,20,10)'\r\n    \r\n    if(loyalindex===80){\r\n    }\r\n\r\n    return (\r\n            <span >\r\n                <input type='text' // No hace falta que sea type = 'number', con el Estado Local lo solucionamos\r\n                value= {input[loyalindex]} // Esto es clave para que la última palabra la tenga el Estado Local con sus validaciones de si es un número entre 1 y 9\r\n                className= {loyalindex%2===0?'unity':'impar'} // Define el color de los números (ver en el browser)\r\n                style={{backgroundColor: back}} // Define el color de fondo de las cajas\r\n                onChange= {e=>changeEach(e)}\r\n                />\r\n            </span>\r\n    )\r\n}"],"mappings":";;;AAAA,SAASA,QAAT,QAAyB,OAAzB;AACA,OAAO,sBAAP;AACA,SAASC,IAAT,EAAeC,MAAf,EAAuBC,IAAvB,EAA6BC,IAA7B,EAAmCC,OAAnC,EAA4CC,IAA5C,EAAkDC,gBAAlD,EAAoEC,YAApE,EAAkFC,WAAlF,EAA+FC,eAA/F,EAAgHC,oBAAhH,EAAsIC,WAAtI,EAAmJC,eAAnJ,QAA0K,+BAA1K;AACA,SAASC,QAAT,QAAyB,gCAAzB;AACA,SAASC,IAAT,QAAqB,uCAArB;AACA,OAAOC,eAAP,MAA4B,8BAA5B;AACA,OAAOC,OAAP,MAAoB,sBAApB;AACA,OAAOC,WAAP,MAAwB,0BAAxB;AACA,OAAOC,WAAP,MAAwB,0BAAxB,C,CAEA;AACA;AACA;;;AAGA,eAAe,SAASC,IAAT,OAA4G;EAAA;;EAAA,IAA9F;IAACC,KAAD;IAAQC,IAAR;IAAcC,UAAd;IAA0BC,KAA1B;IAAiCC,QAAjC;IAA2CC,YAA3C;IAAyDC,YAAzD;IAAuEC,YAAvE;IAAqFC;EAArF,CAA8F;EAEvH;EACA,IAAI,CAACC,KAAD,EAAQC,QAAR,IAAmB/B,QAAQ,CAACsB,IAAD,CAA/B;EACA,IAAI,CAACU,IAAD,EAAOC,OAAP,IAAiBjC,QAAQ,CAAC,EAAD,CAA7B;EACA,IAAI,CAACkC,KAAD,EAAQC,QAAR,IAAmBnC,QAAQ,CAAC,EAAD,CAA/B;EACA,IAAI,CAACoC,KAAD,EAAQC,QAAR,IAAmBrC,QAAQ,CAAC,EAAD,CAA/B,CANuH,CAOvH;;EACA,IAAI,CAACsC,KAAD,EAAQC,QAAR,IAAoBvC,QAAQ,CAAC,EAAD,CAAhC,CARuH,CAQjF;EAGtC;EACA;;EACA,SAASwC,UAAT,CAAoBC,CAApB,EAAsB;IAElB,IAAIC,GAAG,GAAED,CAAC,CAACE,MAAF,CAASC,KAAlB;IACAC,OAAO,CAACC,GAAR,CAAY,2CAAZ,EAAyDzB,KAAzD,EAAgEE,UAAhE,EAA4EmB,GAA5E,EAAiF,OAAOA,GAAxF;IACAG,OAAO,CAACC,GAAR,CAAYC,KAAK,CAACL,GAAD,CAAjB,EAJkB,CAMlB;IACA;;IACA,IAAGA,GAAG,CAACM,MAAJ,GAAa,CAAhB,EAAmB,OAAOT,QAAQ,CAAC,EAAC,GAAGD,KAAJ;MAAW,CAACf,UAAD,GAAcmB,GAAG,CAAC,CAAD;IAA5B,CAAD,CAAf,CARD,CASlB;;IACA,IAAGK,KAAK,CAACL,GAAD,CAAL,IAAcA,GAAG,KAAK,CAAtB,IAA2BA,GAAG,KAAK,GAAtC,EAA2C,OAAOH,QAAQ,CAAC,EAAC,GAAGD,KAAJ;MAAW,CAACf,UAAD,GAAc;IAAzB,CAAD,CAAf;IAE3CgB,QAAQ,CAAC,EAAC,GAAGD,KAAJ;MAAW,CAACf,UAAD,GAAcmB;IAAzB,CAAD,CAAR,CAZkB,CAalB;;IAEA,IAAGA,GAAG,KAAG,EAAT,EAAarB,KAAK,GAAE,CAAP,CAfK,CAeI;;IACtB,IAAGqB,GAAG,KAAG,EAAT,EAAarB,KAAK,GAAE4B,QAAQ,CAACP,GAAD,CAAf;IAEbzC,IAAI,CAACsB,UAAD,CAAJ,GAAkBF,KAAlB;IACAU,QAAQ,CAAC7B,MAAM,CAACqB,UAAD,CAAP,CAAR,CAnBkB,CAmBW;;IAC7BE,QAAQ,CAAChB,WAAW,CAACa,IAAD,CAAZ,CAAR,CApBkB,CAoBU;;IAE5B,IAAI4B,QAAQ,GAACxC,eAAe,CAAC,MAAD,EAASF,YAAY,CAAC,CAAD,CAArB,EAA0B,CAA1B,CAA5B,CAtBkB,CAsBuC;;IACzD,IAAI2C,QAAQ,GAACzC,eAAe,CAAC,MAAD,EAASF,YAAY,CAAC,CAAD,CAArB,EAA0B,CAA1B,CAA5B,CAvBkB,CAuBuC;;IACzD,IAAI4C,QAAQ,GAAC1C,eAAe,CAAC,MAAD,EAASF,YAAY,CAAC,CAAD,CAArB,EAA0B,CAA1B,CAA5B,CAxBkB,CAwBuC;IAEzD;IAEA;;IACA,IAAI6C,MAAM,GAAE,EAAZ;IAEAA,MAAM,GAAErC,eAAe,CAACqC,MAAD,EAASH,QAAT,CAAvB,CA/BkB,CAiClB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;;IAEA,IAAII,OAAO,GAAE,EAAb;IAEAA,OAAO,GAAEtC,eAAe,CAACsC,OAAD,EAAUH,QAAV,CAAxB;IAEA,IAAII,OAAO,GAAE,EAAb;IAEAA,OAAO,GAAEvC,eAAe,CAACuC,OAAD,EAAUH,QAAV,CAAxB,CAlDkB,CAoDlB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;;IACA,IAAII,OAAO,GAAEvC,OAAO,CAACoC,MAAD,EAAS,MAAT,EAAiB1C,oBAAjB,CAApB,CA/DkB,CAiElB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;;IACA,IAAI8C,QAAQ,GAAExC,OAAO,CAACqC,OAAD,EAAU,MAAV,EAAkB3C,oBAAlB,CAArB;IAEA,IAAI+C,QAAQ,GAAEzC,OAAO,CAACsC,OAAD,EAAU,MAAV,EAAkB1C,eAAlB,CAArB,CAnFkB,CAqFlB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;IACA;IAEA;;IACAK,WAAW,CAACsC,OAAD,CAAX,CA1GkB,CA2GlB;IACA;IACA;IACA;IACA;IACA;IACA;;IACAtC,WAAW,CAACuC,QAAD,CAAX;IACAvC,WAAW,CAACwC,QAAD,CAAX,CAnHkB,CAqHlB;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IAEA;;IACAvC,WAAW,CAACa,IAAD,EAAOwB,OAAP,EAAgBvB,OAAhB,CAAX,CAxIkB,CA0IlB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAGA;;IACAd,WAAW,CAACe,KAAD,EAAQuB,QAAR,EAAkBtB,QAAlB,CAAX;IAEAhB,WAAW,CAACiB,KAAD,EAAQsB,QAAR,EAAkBrB,QAAlB,CAAX,CAjLkB,CAoLlB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EAEH,CApOsH,CAsOvH;EACA;;;EACA,IAAIb,KAAJ,EAAW;IACP,IAAGH,KAAK,KAAG,CAAX,EAAa;MACTsC,QAAQ,CAACC,oBAAT,CAA8B,OAA9B,EAAuCrC,UAAvC,EAAmDqB,KAAnD,GAA0DvB,KAA1D;IACH;;IACD,IAAG,OAAOA,KAAP,KAAiB,QAAjB,IAA6B0B,KAAK,CAAC1B,KAAD,CAArC,EAA6C;MACzC;MACAsC,QAAQ,CAACC,oBAAT,CAA8B,OAA9B,EAAuCrC,UAAvC,EAAmDqB,KAAnD,GAA0D,CAA1D;IACH;;IACD,IAAGvB,KAAK,KAAG,CAAX,EAAc;MACVsC,QAAQ,CAACC,oBAAT,CAA8B,OAA9B,EAAuCrC,UAAvC,EAAmDqB,KAAnD,GAA0D,EAA1D;IACH;EACJ,CAnPsH,CAqPvH;;;EACA,IAAIiB,SAAS,GAAEjD,WAAW,CAACW,UAAD,CAA1B;EACA,IAAIuC,IAAI,GAAED,SAAS,CAAC,CAAD,CAAT,GAAa,CAAb,KAAiB,CAAjB,GAAoB,OAApB,GAA8B,eAAxC;;EAEA,IAAGtC,UAAU,KAAG,EAAhB,EAAmB,CAClB;;EAED,oBACQ;IAAA,uBACI;MAAO,IAAI,EAAC,MAAZ,CAAmB;MAAnB;MACA,KAAK,EAAGe,KAAK,CAACf,UAAD,CADb,CAC2B;MAD3B;MAEA,SAAS,EAAGA,UAAU,GAAC,CAAX,KAAe,CAAf,GAAiB,OAAjB,GAAyB,OAFrC,CAE8C;MAF9C;MAGA,KAAK,EAAE;QAACwC,eAAe,EAAED;MAAlB,CAHP,CAGgC;MAHhC;MAIA,QAAQ,EAAGrB,CAAC,IAAED,UAAU,CAACC,CAAD;IAJxB;MAAA;MAAA;MAAA;IAAA;EADJ;IAAA;IAAA;IAAA;EAAA,QADR;AAUH;;GAtQuBrB,I;;KAAAA,I"},"metadata":{},"sourceType":"module"}