{"ast":null,"code":"var _jsxFileName = \"F:\\\\code\\\\SudoQubs\\\\src\\\\components\\\\4-Four.jsx\",\n    _s = $RefreshSig$();\n\nimport { useState } from 'react';\nimport '../styles/0-zero.css';\nimport { qubs, update, cols, boxs, restore, poss, detectdifficulty, megasolution, howmanyQubs, pointerMistakes, rows_cols_to_squares, getBoxFromQ } from '../functions/2-Estructures.js';\nimport { solution } from '../functions/0-Unrepeatable.js';\nimport { type } from '@testing-library/user-event/dist/type';\nimport RepeatedIndexes from '../functions/RepeatedIndexes';\nimport Squares from '../functions/Squares';\nimport ChangeColor from '../functions/ChangeColor'; // const { qubs, update, cols, boxs, restore } = require('../functions/2-Estructures.js');\n// const { solution } = require('../functions/0-Unrepeatable.js');\n// const { create } = require('../functions/3-Creator.js')\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Four(_ref) {\n  _s();\n\n  let {\n    unity,\n    rows,\n    loyalindex,\n    carga,\n    sendFill,\n    sendRepsRows,\n    sendRepsCols,\n    sendRepsBoxs,\n    sending\n  } = _ref;\n  //ESTADOS LOCALES\n  let [filas, setFilas] = useState(rows);\n  let [reps, setReps] = useState([]);\n  let [repsC, setRepsC] = useState([]);\n  let [repsB, setRepsB] = useState([]);\n  let [noreps, setNoreps] = useState([]);\n  let [input, setInput] = useState({}); //Estado que maneja cada input del sudoku\n  //FUNCIONES\n  //Función que se ejecuta por cada ingreso de cualquier caracter en cualquier casilla:\n\n  function changeEach(e) {\n    var val = e.target.value;\n    console.log(\"unity, typeof loyalindex, val, typeof val\", unity, loyalindex, val, typeof val);\n    console.log(isNaN(val)); //_______________________________________________________\n    //LÍNEA QUE NO ADMITE UNA CADENA DE LARGO MAYOR A 1\n\n    if (val.length > 1) return setInput({ ...input,\n      [loyalindex]: val[0]\n    }); //MÓDULO QUE SOLO DEJA ENTRAR NÚMEROS ENTRE EL 1 AL 9\n\n    if (isNaN(val) || val === 0 || val === '0') return setInput({ ...input,\n      [loyalindex]: ''\n    });\n    setInput({ ...input,\n      [loyalindex]: val\n    }); // ______________________________________________________\n\n    if (val === '') {\n      //Si se borra un numero va a llegar un string vacío\n      unity = 0;\n    }\n\n    if (val !== '') {\n      unity = parseInt(val);\n    }\n\n    qubs[loyalindex] = unity;\n    setFilas(update(loyalindex)); //CON ESTE update(q) ACTUALIZO TODAS LAS ENTIDADES (COLUMNAS, FILAS y CAJAS)\n\n    sendFill(howmanyQubs(rows)); //ESTE ES PARA CONTAR CUÁNTOS CASILLEROS ESTÁN LLENOS y CUÁNTOS VACÍOS\n\n    let repsRows = pointerMistakes('rows', megasolution(2), 2); //DETECTOR DE REPETICIONES EN LAS FILAS\n\n    let repsCols = pointerMistakes('cols', megasolution(2), 2); //PARA DETECTAR REPETICIONES EN LAS COLUMNAS\n\n    let repsBoxs = pointerMistakes('boxs', megasolution(2), 2); //PARA DETECTAR REPETICIONES EN LAS CAJAS\n\n    console.log(repsRows, repsCols, repsBoxs); //PARTE 'A' ROWS\n\n    let indexs = [];\n    indexs = RepeatedIndexes(indexs, repsRows); // for(let ab= 0; ab< repsRows.length; ab++){\n    //     indexs[ab]= []\n    //     indexs[ab].push(repsRows[ab]['indice'])\n    //     for(let ac= 0; ac< repsRows[ab]['subindice'].length; ac++){\n    //         // console.log(repsRows[ab]['subindice'][ac]) //ÍNDICES\n    //         indexs[ab].push(repsRows[ab]['subindice'][ac]['reps'])\n    //     }\n    // }\n    //PARTE 'A' COLS\n\n    let indexsC = [];\n    indexsC = RepeatedIndexes(indexsC, repsCols); // for(let ab= 0; ab< repsCols.length; ab++){\n    //     indexsC[ab]= []\n    //     indexsC[ab].push(repsCols[ab]['indice'])\n    //     for(let ac= 0; ac< repsCols[ab]['subindice'].length; ac++){\n    //         // console.log(repsCols[ab]['subindice'][ac]) //ÍNDICES\n    //         indexsC[ab].push(repsCols[ab]['subindice'][ac]['reps'])\n    //     }\n    // }\n\n    console.log(indexs, indexsC); //PARTE 'B' ROWS\n\n    let squares = Squares(indexs, 'rows'); // let squares= []\n    // for (let i = 0; i < indexs.length; i++) {\n    //     let first= indexs[i][0]\n    //     console.log('first', first)\n    //     for (let u=1;u<indexs[i].length;u++) {\n    //         let second1= indexs[i][u][0]\n    //         let second2= indexs[i][u][1]\n    //         console.log('second', second1, second2)\n    //         let sq1= rows_cols_to_squares(first, second1, 'rows')\n    //         let sq2= rows_cols_to_squares(first, second2, 'rows')\n    //         squares.push(sq1, sq2)\n    //     }\n    // }\n\n    console.log(squares); //PARTE 'B' COLS \n\n    let squaresC = Squares(indexsC, 'cols'); // let squaresC= []\n    // for (let i = 0; i < indexsC.length; i++) {\n    //     let first= indexsC[i][0]\n    //     console.log('first', first)\n    //     for (let u=1;u<indexsC[i].length;u++) {\n    //         let second1= indexsC[i][u][0]\n    //         let second2= indexsC[i][u][1]\n    //         console.log('second', second1, second2)\n    //         let sq1= rows_cols_to_squares(first, second1, 'cols')\n    //         let sq2= rows_cols_to_squares(first, second2, 'cols')\n    //         squaresC.push(sq1, sq2)\n    //     }\n    // }\n\n    console.log(squaresC); //HASTA ACÄ TODO 10 PUNTOS\n    //ANTES HAY QUE HACER LA COMPARACIÓN ENTRE useState() Y pointerMistakes()\n    //EN BASE A ESO, MANDAR A PINTAR Y MANDAR A DESPINTAR\n    // 'C' ROWS\n\n    ChangeColor(squares); // for(let gamma= 0; gamma<squares.length; gamma++){\n    //     // console.log(squares[gamma][0])\n    //     // console.log(squares[gamma][1])\n    //     document.getElementsByTagName('input')[squares[gamma]].style.color= 'red'\n    //     document.getElementsByTagName('input')[squares[gamma]].style.color= 'red'\n    // }\n    // 'C' COLS\n\n    ChangeColor(squaresC); // for(let gamma= 0; gamma<squaresC.length; gamma++){\n    //     // console.log(squares[gamma][0])\n    //     // console.log(squares[gamma][1])\n    //     document.getElementsByTagName('input')[squaresC[gamma]].style.color= 'red'\n    //     document.getElementsByTagName('input')[squaresC[gamma]].style.color= 'red'\n    // }\n    //Y PUDIERA SER QUE HASTA ACÁ, PERFECTO TAMBIÉN\n    //LO QUE VIENE AHORA SERÍA LO RECIÉN MENCIONADO SOBRE COMPARAR PARA DESPINTAR\n    //TRAEME useState() que contiene lo de la anterior vuelta, (1)\n    //SI ES DISTINTO DE VACÍO, LO ANALIZAMOS. (2)\n    //Recordar que useState() siempre va a guardar todos los datos que le mandemos.\n    //Si nada los borra, quedan ahí. Entonces:\n    //SI useState() PRESENTA DATOS DE pointerMistakes(), IGNORAR ESTOS (3)\n    //SI PRESENTA DATOS QUE pointerMistakes() NO REGISTRÓ, DESPINTARLOS (4)\n    //Nota: al mencionar pointerMistakes(), hacemos referencia al post-producto: es decir los squares que están dentro del Array squares\n    // PARTE 'D' ROWS\n\n    let noReps = []; // if(reps.length){ //(1), (2)\n\n    for (let delta = 0; delta < reps.length; delta++) {\n      let test = [];\n      let e = 0;\n\n      for (let eco = 0; eco < squares.length; eco++) {\n        // if(eco===delta)continue\n        // if(reps[delta][0]===squares[eco][0]){\n        //     console.log('continue en 0')\n        // }\n        // if(reps[delta][1]===squares[eco][1]){\n        //     console.log('continue en 1')\n        // }\n        if (reps[delta] === squares[eco]) {\n          // console.log(reps[delta, squares[eco]], ' iguales')\n          test.push(1);\n        }\n\n        e = eco; // if(!test.length && e===squares.length-1){\n        //     noReps.push(reps[delta])\n        // }\n      }\n\n      if (!test.length) {\n        noReps.push(reps[delta]);\n      }\n    } // }\n\n\n    console.log(reps, squares, noReps);\n\n    for (let ohmega = 0; ohmega < noReps.length; ohmega++) {\n      let color = noReps[ohmega] % 2 === 0 ? 'orange' : 'orangered';\n      console.log(noReps[ohmega], color);\n      document.getElementsByTagName('input')[noReps[ohmega]].style.color = color;\n    }\n\n    setReps(squares); // PARTE 'D' COLS\n\n    let noRepsC = []; // if(reps.length){ //(1), (2)\n\n    for (let delta = 0; delta < repsC.length; delta++) {\n      let test = [];\n      let e = 0;\n\n      for (let eco = 0; eco < squaresC.length; eco++) {\n        // if(eco===delta)continue\n        // if(reps[delta][0]===squares[eco][0]){\n        //     console.log('continue en 0')\n        // }\n        // if(reps[delta][1]===squares[eco][1]){\n        //     console.log('continue en 1')\n        // }\n        if (repsC[delta] === squaresC[eco]) {\n          // console.log(reps[delta, squares[eco]], ' iguales')\n          test.push(1);\n        }\n\n        e = eco; // if(!test.length && e===squares.length-1){\n        //     noReps.push(reps[delta])\n        // }\n      }\n\n      if (!test.length) {\n        noRepsC.push(repsC[delta]);\n      }\n    } // }\n\n\n    console.log(repsC, squaresC, noRepsC);\n\n    for (let ohmega = 0; ohmega < noRepsC.length; ohmega++) {\n      let color = noRepsC[ohmega] % 2 === 0 ? 'orange' : 'orangered';\n      console.log(noRepsC[ohmega], color);\n      document.getElementsByTagName('input')[noRepsC[ohmega]].style.color = color;\n    }\n\n    setRepsC(squaresC);\n  } //CONDICIONALES \n  //Cuando el botón Cargar se pulsa, carga es === true, y el sudoku se llena con los datos del algoritmo generador\n\n\n  if (carga) {\n    if (unity !== 0) {\n      document.getElementsByTagName(\"input\")[loyalindex].value = unity;\n    }\n\n    if (typeof unity !== 'number' || isNaN(unity)) {\n      console.log(unity, typeof unity, loyalindex);\n      document.getElementsByTagName(\"input\")[loyalindex].value = 0;\n    }\n\n    if (unity === 0) {\n      document.getElementsByTagName(\"input\")[loyalindex].value = '';\n    }\n  } //UN DETALLE ESTÉTICO PARA CAMBIAR EL COLOR DE FONDO DE LAS CAJAS (VER EN EL BROWSER)\n\n\n  let box_Array = getBoxFromQ(loyalindex);\n  let back = box_Array[0] % 2 === 0 ? 'black' : 'rgb(30,20,10)';\n\n  if (loyalindex === 80) {}\n\n  return /*#__PURE__*/_jsxDEV(\"span\", {\n    children: /*#__PURE__*/_jsxDEV(\"input\", {\n      type: \"text\" // No hace falta que sea type = 'number', con el Estado Local lo solucionamos\n      ,\n      value: input[loyalindex] // Esto es clave para que la última palabra la tenga el Estado Local con sus validaciones de si es un número entre 1 y 9\n      ,\n      className: loyalindex % 2 === 0 ? 'unity' : 'impar' // Define el color de los números (ver en el browser)\n      ,\n      style: {\n        backgroundColor: back\n      } // Define el color de fondo de las cajas\n      ,\n      onChange: e => changeEach(e)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 257,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 256,\n    columnNumber: 13\n  }, this);\n}\n\n_s(Four, \"Mb3rfF9oKgpgAO+QJtpcfr4dP5I=\");\n\n_c = Four;\n\nvar _c;\n\n$RefreshReg$(_c, \"Four\");","map":{"version":3,"names":["useState","qubs","update","cols","boxs","restore","poss","detectdifficulty","megasolution","howmanyQubs","pointerMistakes","rows_cols_to_squares","getBoxFromQ","solution","type","RepeatedIndexes","Squares","ChangeColor","Four","unity","rows","loyalindex","carga","sendFill","sendRepsRows","sendRepsCols","sendRepsBoxs","sending","filas","setFilas","reps","setReps","repsC","setRepsC","repsB","setRepsB","noreps","setNoreps","input","setInput","changeEach","e","val","target","value","console","log","isNaN","length","parseInt","repsRows","repsCols","repsBoxs","indexs","indexsC","squares","squaresC","noReps","delta","test","eco","push","ohmega","color","document","getElementsByTagName","style","noRepsC","box_Array","back","backgroundColor"],"sources":["F:/code/SudoQubs/src/components/4-Four.jsx"],"sourcesContent":["import { useState } from 'react';\r\nimport '../styles/0-zero.css';\r\nimport { qubs, update, cols, boxs, restore, poss, detectdifficulty, megasolution, howmanyQubs, pointerMistakes, rows_cols_to_squares, getBoxFromQ } from '../functions/2-Estructures.js';\r\nimport { solution } from '../functions/0-Unrepeatable.js';\r\nimport { type } from '@testing-library/user-event/dist/type';\r\nimport RepeatedIndexes from '../functions/RepeatedIndexes';\r\nimport Squares from '../functions/Squares';\r\nimport ChangeColor from '../functions/ChangeColor';\r\n\r\n// const { qubs, update, cols, boxs, restore } = require('../functions/2-Estructures.js');\r\n// const { solution } = require('../functions/0-Unrepeatable.js');\r\n// const { create } = require('../functions/3-Creator.js')\r\n\r\n\r\nexport default function Four({unity, rows, loyalindex, carga, sendFill, sendRepsRows, sendRepsCols, sendRepsBoxs, sending}){\r\n\r\n    //ESTADOS LOCALES\r\n    let [filas, setFilas]= useState(rows) \r\n    let [reps, setReps]= useState([])\r\n    let [repsC, setRepsC]= useState([])\r\n    let [repsB, setRepsB]= useState([])\r\n    let [noreps, setNoreps]= useState([ ])\r\n    let [input, setInput] = useState({ }) //Estado que maneja cada input del sudoku\r\n\r\n\r\n    //FUNCIONES\r\n    //Función que se ejecuta por cada ingreso de cualquier caracter en cualquier casilla:\r\n    function changeEach(e){\r\n\r\n        var val= e.target.value\r\n        console.log(\"unity, typeof loyalindex, val, typeof val\", unity, loyalindex, val, typeof val)\r\n        console.log(isNaN(val))\r\n        \r\n        //_______________________________________________________\r\n        //LÍNEA QUE NO ADMITE UNA CADENA DE LARGO MAYOR A 1\r\n        if(val.length > 1) return setInput({...input, [loyalindex]: val[0]})\r\n        //MÓDULO QUE SOLO DEJA ENTRAR NÚMEROS ENTRE EL 1 AL 9\r\n        if(isNaN(val) || val === 0 || val === '0') return setInput({...input, [loyalindex]: ''})\r\n\r\n        setInput({...input, [loyalindex]: val}) \r\n        // ______________________________________________________\r\n\r\n\r\n        if(val===''){ //Si se borra un numero va a llegar un string vacío\r\n            unity= 0\r\n        }\r\n        if(val!==''){\r\n            unity= parseInt(val)\r\n        }\r\n\r\n        qubs[loyalindex]= unity\r\n        setFilas(update(loyalindex)) //CON ESTE update(q) ACTUALIZO TODAS LAS ENTIDADES (COLUMNAS, FILAS y CAJAS)\r\n        sendFill(howmanyQubs(rows)) //ESTE ES PARA CONTAR CUÁNTOS CASILLEROS ESTÁN LLENOS y CUÁNTOS VACÍOS\r\n        \r\n        let repsRows=pointerMistakes('rows', megasolution(2), 2) //DETECTOR DE REPETICIONES EN LAS FILAS\r\n        let repsCols=pointerMistakes('cols', megasolution(2), 2) //PARA DETECTAR REPETICIONES EN LAS COLUMNAS\r\n        let repsBoxs=pointerMistakes('boxs', megasolution(2), 2) //PARA DETECTAR REPETICIONES EN LAS CAJAS\r\n\r\n        console.log(repsRows, repsCols, repsBoxs)\r\n\r\n        //PARTE 'A' ROWS\r\n        let indexs= []\r\n\r\n        indexs= RepeatedIndexes(indexs, repsRows)\r\n\r\n        // for(let ab= 0; ab< repsRows.length; ab++){\r\n        //     indexs[ab]= []\r\n        //     indexs[ab].push(repsRows[ab]['indice'])\r\n        //     for(let ac= 0; ac< repsRows[ab]['subindice'].length; ac++){\r\n        //         // console.log(repsRows[ab]['subindice'][ac]) //ÍNDICES\r\n        //         indexs[ab].push(repsRows[ab]['subindice'][ac]['reps'])\r\n        //     }\r\n        // }\r\n        \r\n        //PARTE 'A' COLS\r\n        let indexsC= []\r\n\r\n        indexsC= RepeatedIndexes(indexsC, repsCols)\r\n\r\n        // for(let ab= 0; ab< repsCols.length; ab++){\r\n        //     indexsC[ab]= []\r\n        //     indexsC[ab].push(repsCols[ab]['indice'])\r\n        //     for(let ac= 0; ac< repsCols[ab]['subindice'].length; ac++){\r\n        //         // console.log(repsCols[ab]['subindice'][ac]) //ÍNDICES\r\n        //         indexsC[ab].push(repsCols[ab]['subindice'][ac]['reps'])\r\n        //     }\r\n        // }\r\n        console.log( indexs, indexsC)\r\n\r\n        //PARTE 'B' ROWS\r\n        let squares= Squares(indexs, 'rows')\r\n\r\n        // let squares= []\r\n        // for (let i = 0; i < indexs.length; i++) {\r\n        //     let first= indexs[i][0]\r\n        //     console.log('first', first)\r\n        //     for (let u=1;u<indexs[i].length;u++) {\r\n        //         let second1= indexs[i][u][0]\r\n        //         let second2= indexs[i][u][1]\r\n        //         console.log('second', second1, second2)\r\n        //         let sq1= rows_cols_to_squares(first, second1, 'rows')\r\n        //         let sq2= rows_cols_to_squares(first, second2, 'rows')\r\n        //         squares.push(sq1, sq2)\r\n        //     }\r\n        // }\r\n        console.log(squares)\r\n        \r\n        //PARTE 'B' COLS \r\n        let squaresC= Squares(indexsC, 'cols')\r\n        // let squaresC= []\r\n        // for (let i = 0; i < indexsC.length; i++) {\r\n        //     let first= indexsC[i][0]\r\n        //     console.log('first', first)\r\n        //     for (let u=1;u<indexsC[i].length;u++) {\r\n        //         let second1= indexsC[i][u][0]\r\n        //         let second2= indexsC[i][u][1]\r\n        //         console.log('second', second1, second2)\r\n        //         let sq1= rows_cols_to_squares(first, second1, 'cols')\r\n        //         let sq2= rows_cols_to_squares(first, second2, 'cols')\r\n        //         squaresC.push(sq1, sq2)\r\n        //     }\r\n        // }\r\n        console.log(squaresC)\r\n\r\n        //HASTA ACÄ TODO 10 PUNTOS\r\n\r\n        //ANTES HAY QUE HACER LA COMPARACIÓN ENTRE useState() Y pointerMistakes()\r\n        //EN BASE A ESO, MANDAR A PINTAR Y MANDAR A DESPINTAR\r\n\r\n        // 'C' ROWS\r\n        ChangeColor(squares)\r\n        // for(let gamma= 0; gamma<squares.length; gamma++){\r\n        //     // console.log(squares[gamma][0])\r\n        //     // console.log(squares[gamma][1])\r\n        //     document.getElementsByTagName('input')[squares[gamma]].style.color= 'red'\r\n        //     document.getElementsByTagName('input')[squares[gamma]].style.color= 'red'\r\n        // }\r\n        // 'C' COLS\r\n        ChangeColor(squaresC)\r\n        // for(let gamma= 0; gamma<squaresC.length; gamma++){\r\n        //     // console.log(squares[gamma][0])\r\n        //     // console.log(squares[gamma][1])\r\n        //     document.getElementsByTagName('input')[squaresC[gamma]].style.color= 'red'\r\n        //     document.getElementsByTagName('input')[squaresC[gamma]].style.color= 'red'\r\n        // }\r\n        //Y PUDIERA SER QUE HASTA ACÁ, PERFECTO TAMBIÉN\r\n\r\n        //LO QUE VIENE AHORA SERÍA LO RECIÉN MENCIONADO SOBRE COMPARAR PARA DESPINTAR\r\n        //TRAEME useState() que contiene lo de la anterior vuelta, (1)\r\n        //SI ES DISTINTO DE VACÍO, LO ANALIZAMOS. (2)\r\n        //Recordar que useState() siempre va a guardar todos los datos que le mandemos.\r\n        //Si nada los borra, quedan ahí. Entonces:\r\n        //SI useState() PRESENTA DATOS DE pointerMistakes(), IGNORAR ESTOS (3)\r\n        //SI PRESENTA DATOS QUE pointerMistakes() NO REGISTRÓ, DESPINTARLOS (4)\r\n\r\n        //Nota: al mencionar pointerMistakes(), hacemos referencia al post-producto: es decir los squares que están dentro del Array squares\r\n\r\n        // PARTE 'D' ROWS\r\n        let noReps= []\r\n        // if(reps.length){ //(1), (2)\r\n            for(let delta=0;delta<reps.length;delta++){\r\n                let test=[]\r\n                let e= 0\r\n                for(let eco=0;eco<squares.length;eco++){\r\n                    // if(eco===delta)continue\r\n                    // if(reps[delta][0]===squares[eco][0]){\r\n                    //     console.log('continue en 0')\r\n                    // }\r\n                    // if(reps[delta][1]===squares[eco][1]){\r\n                    //     console.log('continue en 1')\r\n                    // }\r\n                    if(reps[delta]===squares[eco]){\r\n                        // console.log(reps[delta, squares[eco]], ' iguales')\r\n                        test.push(1)\r\n                    }\r\n                    e= eco\r\n                    // if(!test.length && e===squares.length-1){\r\n                    //     noReps.push(reps[delta])\r\n                    // }\r\n                }\r\n                if(!test.length){\r\n                    noReps.push(reps[delta])\r\n                }\r\n            }\r\n        // }\r\n        console.log(reps, squares, noReps)\r\n        for(let ohmega=0; ohmega< noReps.length; ohmega++){\r\n            let color= noReps[ohmega] % 2===0? 'orange':'orangered'\r\n            console.log(noReps[ohmega], color)\r\n            document.getElementsByTagName('input')[noReps[ohmega]].style.color= color\r\n        }\r\n        setReps(squares)\r\n\r\n        \r\n        // PARTE 'D' COLS\r\n        let noRepsC= []\r\n        // if(reps.length){ //(1), (2)\r\n            for(let delta=0;delta<repsC.length;delta++){\r\n                let test=[]\r\n                let e= 0\r\n                for(let eco=0;eco<squaresC.length;eco++){\r\n                    // if(eco===delta)continue\r\n                    // if(reps[delta][0]===squares[eco][0]){\r\n                    //     console.log('continue en 0')\r\n                    // }\r\n                    // if(reps[delta][1]===squares[eco][1]){\r\n                    //     console.log('continue en 1')\r\n                    // }\r\n                    if(repsC[delta]===squaresC[eco]){\r\n                        // console.log(reps[delta, squares[eco]], ' iguales')\r\n                        test.push(1)\r\n                    }\r\n                    e= eco\r\n                    // if(!test.length && e===squares.length-1){\r\n                    //     noReps.push(reps[delta])\r\n                    // }\r\n                }\r\n                if(!test.length){\r\n                    noRepsC.push(repsC[delta])\r\n                }\r\n            }\r\n        // }\r\n        console.log(repsC, squaresC, noRepsC)\r\n        for(let ohmega=0; ohmega< noRepsC.length; ohmega++){\r\n            let color= noRepsC[ohmega] % 2===0? 'orange':'orangered'\r\n            console.log(noRepsC[ohmega], color)\r\n            document.getElementsByTagName('input')[noRepsC[ohmega]].style.color= color\r\n        }\r\n        setRepsC(squaresC)\r\n\r\n    }\r\n\r\n    //CONDICIONALES \r\n    //Cuando el botón Cargar se pulsa, carga es === true, y el sudoku se llena con los datos del algoritmo generador\r\n    if (carga) {\r\n        if(unity!==0){\r\n            document.getElementsByTagName(\"input\")[loyalindex].value= unity\r\n        }\r\n        if(typeof unity !== 'number' || isNaN(unity)){\r\n            console.log(unity, typeof unity, loyalindex)\r\n            document.getElementsByTagName(\"input\")[loyalindex].value= 0\r\n        }\r\n        if(unity===0 ){\r\n            document.getElementsByTagName(\"input\")[loyalindex].value= ''\r\n        }\r\n    }\r\n\r\n    //UN DETALLE ESTÉTICO PARA CAMBIAR EL COLOR DE FONDO DE LAS CAJAS (VER EN EL BROWSER)\r\n    let box_Array= getBoxFromQ(loyalindex)\r\n    let back= box_Array[0]%2===0? 'black' : 'rgb(30,20,10)'\r\n    \r\n    if(loyalindex===80){\r\n    }\r\n\r\n    return (\r\n            <span >\r\n                <input type='text' // No hace falta que sea type = 'number', con el Estado Local lo solucionamos\r\n                value= {input[loyalindex]} // Esto es clave para que la última palabra la tenga el Estado Local con sus validaciones de si es un número entre 1 y 9\r\n                className= {loyalindex%2===0?'unity':'impar'} // Define el color de los números (ver en el browser)\r\n                style={{backgroundColor: back}} // Define el color de fondo de las cajas\r\n                onChange= {e=>changeEach(e)}\r\n                />\r\n            </span>\r\n    )\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}