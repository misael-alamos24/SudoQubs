{"ast":null,"code":"// import { solution } from \"./0-Unrepeatable.js\";\n// // const {solution} = require('../functions/0-Unrepeatable.js');// import { solution } from \"./0-Unrepeatable\"\n// // import { boxs, cols, poss, qubs, resetSquare, rows, update, updateBox, updateCol, updateRow } from \"./2-Estructures\";\n// // poss()\n// let cols, boxs, rows, qubs\n//     rows= []\n//     cols= []\n//     boxs= []\n//     for (let r= 0; r< 9; r++){\n//         cols[r]= []\n//         boxs[r]= []\n//         rows[r]= []\n//     }\n//     qubs= []\n//     for (let q= 1; q<= 81; q++){\n//         qubs.push(0)\n//     }\n// // _________________________________________\n// /* Funciones auxiliares usadas para updatear */\n// function floor (a,b) { \n//     return Math.floor(a/b)\n// }\n// function modul (a,b) {\n//     return a % b\n// }\n// // _________________________________________\n// function updateCol(inx, nueve) {\n//     cols[modul(inx, nueve)][floor(inx,nueve)]= qubs[inx]\n//     return qubs[inx]\n// }\n// function updateRow(inx,nueve) {\n//     rows[floor(inx,nueve)][modul(inx,nueve)]= qubs[inx]\n//     return qubs[inx]\n// }\n// function updateBox(q,nueve,x,y) {\n//     //para 6x6 => 2,3,2,3,3 => variante 11 \n//     var gross= Math.floor(q / nueve) //indica el numero de fila\n// //calculamos el index vertical\n//     var index= Math.floor(gross / x) //este da 0, 1 ó 2\n// //lo usamos para calcular el box exacto al cual pertenecerá\n//     var module= (q % nueve) \n//     var foundbox= Math.floor(module / y) + index * x //índice del box -> 0 al 8\n//     let indexbox = (Math.floor(q/nueve)*y + q%y) %nueve //índice puntual -> 0 al 8\n//     boxs[foundbox][indexbox] = qubs[q]\n//     return `boxs[${foundbox}][${indexbox}], actualizado: ${boxs[foundbox][indexbox]}`\n// }\n// //Exportables solo las siguientes functions\n// const update = (q, nueve, x, y, cols, rows) => { //Actualiza un qube puntual => q\n//     updateBox(q, nueve, x, y)\n//     updateCol(q, nueve, cols)\n//     updateRow(q, nueve, rows)\n// }\n// function resetSquare(q, nueve, x, y) { //Resetea un qube puntual => q\n//     qubs[q]= 0\n//     updateBox(q, nueve, x, y)\n//     updateCol(q, nueve)\n//     updateRow(q, nueve)\n// }\n// // (\n// function possCols (nueve){//possCols\n//     let loop= nueve -1\n//     //    pseudo \n//     //    tengo que agarrar qubs que va del 1 al 81\n//     //    hacer iteraciones de 0 a 8\n//     //    a todos los 0, mandarlos al indice cols[0]\n//     //    a todos los 8, mandarlos al indice cols[8]\n//     var ochouno= 0\n//     for(let alfa= 0; alfa <= loop; alfa++) {\n//         for(let beta= 0; beta <= loop; beta++) {\n//             cols[beta][alfa]= qubs[ochouno] //intercambiando los índices beta y alfa entre sí conseguimos columna o fila según se requiera\n//             ochouno++\n//         }\n//     }\n//     return cols\n// }\n// function possRows(nueve){\n//     let loop= nueve -1\n//     var ochouno= 0\n//     for(let alfa= 0; alfa <= loop; alfa++) {\n//         for(let beta= 0; beta <= loop; beta++) {\n//             rows[alfa][beta]= qubs[ochouno] \n//             ochouno++\n//         }\n//     }\n//     return rows\n// }\n// function possBoxs(){\n//     for (let a= 0; a < 81; a++) {\n//         updateBox(a)\n//     }\n//     return boxs\n// }\n// function poss(){\n//     for (let a= 0; a < 81; a++) {\n//         update(a)\n//     }\n// }\n// function possRandC(boxs){\n//     possCols()\n//     possRows()\n//     boxs= possCols()\n//     console.log(boxs)\n// }\n// function restore(){\n//     for (let a= 0; a < 81; a++) {\n//         resetSquare(a)\n//     }\n// }\n// function updateEvery(){\n//     for (let a= 0; a < 81; a++) {\n//         update(a)\n//     }\n// }\n// function megasolution(quantity){\n//     let b= []\n//     let c=[]\n//     let r=[]\n//     for (let a= 0; a < 9; a++) {\n//         r.push(solution(rows[a], quantity)) \n//         c.push(solution(cols[a], quantity)) \n//         b.push(solution(boxs[a], quantity)) \n//     }\n//     let concat= {rows: r, boxs: b, cols: c}\n//     return concat\n// }\n// function megasolutionBy(entity, quantity){\n//     let b= []\n//     let c=[]\n//     let r=[]\n//     let concat\n//     for (let a= 0; a < 9; a++) {\n//         if(entity==='rows') {r.push(solution(rows[a], quantity)) ; concat= r}\n//         if(entity==='cols') {c.push(solution(cols[a], quantity)) ; concat= c}\n//         if(entity==='boxs') {b.push(solution(boxs[a], quantity)) ; concat= b}\n//     }\n//     return concat\n// }\n// function pointerMistakes(entityString, concat, quantity){\n//     let response= []\n//     let e= concat[entityString]\n//     for(let a=0; a<e.length; a++){\n//         if(e[a]!==-1){\n//             response.push({\n//                 indice: a,\n//                 subindice: e[a]\n//             })\n//         }\n//     }\n//     if(quantity> 1){\n//         return response\n//     }\n//     if(!quantity || quantity===1){\n//         return [response[0]]\n//     }\n// }\n// function detectdifficulty(qubs){\n//     let cont=[]\n//     for(let a=0;a<81;a++){\n//         if(qubs[a]!==0){\n//             cont.push(a)\n//         }\n//     }\n//     return cont\n// }\n// function updateEveryCols(){ //Hace un bucle de 81 iteraciones para actualizar las cols respecto a los qubs\n//     for(let b=0;b<81;b++) updateCol(b) \n// }\n// function updateQubsBy(what){\n//     var q= 0\n//     var qubes= []\n//     for(let aa= 0; aa < 9; aa++){\n//         for(let a= 0; a < 9; a++){\n//             if(what===\"rows\") {\n//                 qubes.push(rows[aa][a])\n//             }\n//             if(what===\"cols\") {\n//                 qubes.push(cols[a][aa])\n//             }\n//             if(what===\"boxs\") {\n//                 var gross= Math.floor(q / 9) //indica el numero de fila\n//                 var index= Math.floor(gross / 3) //este da 0, 1 ó 2\n//                 var module= (q % 9)\n//                 let indexbox = (Math.floor(q/9)*3 + q%3) %9 //índice puntual -> 0 al 8\n//                 var foundbox= Math.floor(module / 3) + index * 3 //índice del box -> 0 al 8\n//                 qubes.push(boxs[foundbox][indexbox])\n//                 q++\n//             }            \n//         }\n//     }\n//     return qubes\n// }\n// function create3(){\n//     var molino= 0\n//     var ochouno= 0\n//     let setRows= new Set()\n//     let setBoxs= new Set()\n//     let theSet= new Set() \n//     for (let aa= 0; aa < 9; aa++) {\n//         for (let a= 0; a < 9; a++) {\n//             molino++\n//             let random= Math.ceil( Math.random() * 9 ) \n//             rows[aa][a]= random\n//             // if (a > 0){\n//                 if ( solution( rows[aa] ) !== -1 ) {\n//                     setRows.add(random)             \n//                     if(setRows.size >= 9) {\n//                         // rows[aa][a]= 0\n//                         // console.log(\"set a 9 en rows\",theSet)\n//                         // console.log(setRows, aa, a, random, ochouno, 'rows == 9', rows[aa])     \n//                         setBoxs= new Set()\n//                         setRows= new Set()\n//                         rows[aa]= [0,0,0,  0,0,0,  0,0,0]\n//                         qubs= updateQubsBy(\"rows\")\n//                         for(let b=0;b<9;b++){\n//                             updateBox((aa * 9) +b)\n//                             updateCol((aa * 9) +b)\n//                         }\n//                         ochouno= aa* 9\n//                         a= -1\n//                         continue\n//                     }\n//                     // console.log(setRows, aa, a, random, ochouno, 'rows', rows[aa])     \n//                     a= a-1\n//                     continue\n//                 }\n//             // }\n//             cols[a][aa]= random\n//             if (aa > 0){\n//                 if ( solution( cols[a] ) !== -1 ) {\n//                     setRows.add(random)             \n//                     if(setRows.size >= 9) {\n//                         // rows[aa][a]= 0\n//                         // console.log(\"set a 9 en rows\",theSet)\n//                         // console.log(setRows, aa, a, random, ochouno, 'rows == 9', rows[aa])     \n//                         setBoxs= new Set()\n//                         setRows= new Set()\n//                         rows[aa]= [0,0,0,  0,0,0,  0,0,0]\n//                         qubs= updateQubsBy(\"rows\")\n//                         for(let b=0;b<9;b++){\n//                             updateBox((aa * 9) +b)\n//                             updateCol((aa * 9) +b)\n//                         }\n//                         ochouno= aa* 9\n//                         a= -1\n//                         continue\n//                     }\n//                     // console.log(setRows, aa, a, random, ochouno, 'rows', rows[aa])     \n//                     a= a-1\n//                     continue\n//                 }\n//             }\n//                 // console.log(\"pasé los continue\")\n//             // }\n//             var q= ochouno\n//             var gross= Math.floor(q / 9) //indica el numero de fila\n//             var index= Math.floor(gross / 3) //este da 0, 1 ó 2\n//             var module= (q % 9)\n//             let indexbox = (Math.floor(q/9)*3 + q%3) %9 //índice puntual -> 0 al 8\n//             var foundbox= Math.floor(module / 3) + index * 3 //índice del box -> 0 al 8\n//             boxs[foundbox][indexbox]= random\n//             // if( indexbox > 0 ) {\n//                 if ( solution( boxs[foundbox] ) !== -1 ) {\n//                     setRows.add(random)\n//                     boxs[foundbox][indexbox]= 0                     \n//                     // console.log(setRows, aa, a, random, ochouno)                    \n//                     if(setRows.size >= 9) {\n//                         setBoxs= new Set()\n//                         setRows= new Set()\n//                         rows[aa]= [0,0,0,  0,0,0,  0,0,0]\n//                         qubs= updateQubsBy(\"rows\")\n//                         for(let b=0;b<9;b++){\n//                             updateBox((aa * 9) +b)\n//                             updateCol((aa * 9) +b)\n//                         }\n//                         ochouno= aa* 9\n//                         a= -1\n//                         // ochouno= aa * 9\n//                         continue\n//                     }\n//                     a=a-1\n//                     // ochouno--\n//                     continue\n//                 }\n//             // }\n//             if(/*solution(cols[a ])=== -1 &&*/ solution(rows[aa])=== -1){\n//                 rows[aa][a]= random\n//                 // cols[a][aa]= random\n//             }\n//             ochouno++\n//             setBoxs= new Set()\n//             setRows= new Set()\n//         }\n//         theSet= new Set()\n//     }\n//     return {ok:\"ok\", molino}\n// }\n// function difficult(level) {\n//     var coef= level *0.4 +5\n//     var diff= Math.random() * 15 \n//     var float= parseFloat(diff.toString().slice(0,3))\n//     if(float > coef) {\n//         return true //se busca un numero\n//     }\n//     return false //no se busca nada\n// }\n// function sudoqubs (level, entity){ //SIEMPRE DEBE TOMAR UN INPUT Y SACAR UN OUTPUT\n//     var suerte\n//     var array = []\n//     for (let index = 0; index < 9; index++) { \n//         for (let ii = 0; ii < 9; ii++) {\n//             suerte= difficult (level)\n//             if (!suerte) {\n//             entity[index][ii]= 0 \n//             array.push(index)\n//             }\n//         }\n//     }\n//     return array.length\n// } //Rehacer esta function: Seniority()\n// function howmanyQubs(rows){\n//     let cont= []\n//     for(let a=0; a<rows.length; a++){\n//         for(let b=0; b<rows[a].length;b++){\n//             if(rows[a][b]!==0){\n//                 cont.push(rows[a][b])\n//             }\n//         }\n//     }\n//     return cont.length\n// }\n// function rows_cols_to_squares(first, second, rowsORcols){\n//     function dependsWhom(dominante, calibrador){\n//         return dominante*9 +calibrador\n//     }\n//     if(rowsORcols==='rows'){\n//         return dependsWhom(first,second)\n//     }\n//     if(rowsORcols==='cols'){\n//         return dependsWhom(second,first)\n//     }\n// }\n// function boxs_to_squares(box, index){\n//     return Math.floor(index/3)*9 + index % 3 + (box % 3) * 3 + Math.floor(box/3) *3*9\n// }\n// function getBoxFromQ(q) {\n//     var gross= Math.floor(q / 9) //indica el numero de fila\n// //calculamos el index vertical\n//     var index= Math.floor(gross / 3) //este da 0, 1 ó 2\n// //lo usamos para calcular el box exacto al cual pertenecerá\n//     var module= (q % 9) \n//     var foundbox= Math.floor(module / 3) + index * 3 //índice del box -> 0 al 8\n//     let indexbox = (Math.floor(q/9)*3 + q%3) %9 //índice puntual -> 0 al 8\n//     // boxs[foundbox][indexbox] = qubs[q]\n//     return [foundbox,indexbox]\n// }\n// poss() // Relaciona las filas, columnas y cajas entre sí\n// restore() // Reinicia el sudoku: borrando los datos de las filas, columnas y cajas\n// let sudoku =create3() // En la variable sudoku se guarda un objeto: {ok: 'ok', molino: number}\n// // create3() genera el sudoku, guardando el rows, cols, y boxs los datos\n// // Solo con el Array rows ya podemos desplegar el sudoku en el browser\n// sudoqubs(5, rows) // Esta función es la que borra ciertos números, según cuántos se borran, se define la dificulad\n// qubs= updateQubsBy(\"rows\") // Qubs es un Array de 81 casilleros, con esta función le pasamos los datos de rows a qubs\n// updateEvery() // Relaciona las filas, columnas y cajas entre sí, cada vez que se agregue un número cuando se esté jugando al sudoku, es necesario ejecutar una variante de esta función. \n// export {\n//     //Para testing\n//     rows, cols, boxs, qubs,\n//     updateRow,\n//     updateCol,\n//     updateBox,\n//     //Para update\n//     update,\n//     //Para reset\n//     resetSquare,\n//     //Para crear estructura sudoku\n//     possCols,\n//     possRows,\n//     possBoxs,\n//     poss,\n//     possRandC,\n//     restore,\n//     detectdifficulty,\n//     megasolution,\n//     megasolutionBy,\n//     create3,\n//     updateQubsBy,\n//     difficult,\n//     //Para crear sudoku lógico:\n//     sudoku,\n//     //Registro de sudoku:\n//     howmanyQubs,\n//     //Registro errores:\n//     pointerMistakes,\n//     //Conversores inversos:\n//     boxs_to_squares,\n//     rows_cols_to_squares,\n//     //conversor regular\n//     getBoxFromQ\n// }","map":{"version":3,"names":[],"sources":["F:/code/SudoQubs/src/functions/2-Estructures.js"],"sourcesContent":["// import { solution } from \"./0-Unrepeatable.js\";\r\n// // const {solution} = require('../functions/0-Unrepeatable.js');// import { solution } from \"./0-Unrepeatable\"\r\n// // import { boxs, cols, poss, qubs, resetSquare, rows, update, updateBox, updateCol, updateRow } from \"./2-Estructures\";\r\n// // poss()\r\n\r\n// let cols, boxs, rows, qubs\r\n\r\n//     rows= []\r\n//     cols= []\r\n//     boxs= []\r\n//     for (let r= 0; r< 9; r++){\r\n//         cols[r]= []\r\n//         boxs[r]= []\r\n//         rows[r]= []\r\n//     }\r\n\r\n//     qubs= []\r\n//     for (let q= 1; q<= 81; q++){\r\n//         qubs.push(0)\r\n//     }\r\n    \r\n// // _________________________________________\r\n// /* Funciones auxiliares usadas para updatear */\r\n// function floor (a,b) { \r\n//     return Math.floor(a/b)\r\n// }\r\n// function modul (a,b) {\r\n//     return a % b\r\n// }\r\n// // _________________________________________\r\n\r\n// function updateCol(inx, nueve) {\r\n//     cols[modul(inx, nueve)][floor(inx,nueve)]= qubs[inx]\r\n//     return qubs[inx]\r\n// }\r\n\r\n// function updateRow(inx,nueve) {\r\n//     rows[floor(inx,nueve)][modul(inx,nueve)]= qubs[inx]\r\n//     return qubs[inx]\r\n// }\r\n\r\n// function updateBox(q,nueve,x,y) {\r\n//     //para 6x6 => 2,3,2,3,3 => variante 11 \r\n        \r\n//     var gross= Math.floor(q / nueve) //indica el numero de fila\r\n// //calculamos el index vertical\r\n//     var index= Math.floor(gross / x) //este da 0, 1 ó 2\r\n// //lo usamos para calcular el box exacto al cual pertenecerá\r\n//     var module= (q % nueve) \r\n\r\n//     var foundbox= Math.floor(module / y) + index * x //índice del box -> 0 al 8\r\n//     let indexbox = (Math.floor(q/nueve)*y + q%y) %nueve //índice puntual -> 0 al 8\r\n    \r\n//     boxs[foundbox][indexbox] = qubs[q]\r\n\r\n//     return `boxs[${foundbox}][${indexbox}], actualizado: ${boxs[foundbox][indexbox]}`\r\n\r\n// }\r\n// //Exportables solo las siguientes functions\r\n// const update = (q, nueve, x, y, cols, rows) => { //Actualiza un qube puntual => q\r\n//     updateBox(q, nueve, x, y)\r\n//     updateCol(q, nueve, cols)\r\n//     updateRow(q, nueve, rows)\r\n// }\r\n\r\n// function resetSquare(q, nueve, x, y) { //Resetea un qube puntual => q\r\n//     qubs[q]= 0\r\n//     updateBox(q, nueve, x, y)\r\n//     updateCol(q, nueve)\r\n//     updateRow(q, nueve)\r\n// }\r\n\r\n\r\n// // (\r\n// function possCols (nueve){//possCols\r\n\r\n//     let loop= nueve -1\r\n//     //    pseudo \r\n//     //    tengo que agarrar qubs que va del 1 al 81\r\n//     //    hacer iteraciones de 0 a 8\r\n//     //    a todos los 0, mandarlos al indice cols[0]\r\n//     //    a todos los 8, mandarlos al indice cols[8]\r\n//     var ochouno= 0\r\n\r\n//     for(let alfa= 0; alfa <= loop; alfa++) {\r\n//         for(let beta= 0; beta <= loop; beta++) {\r\n//             cols[beta][alfa]= qubs[ochouno] //intercambiando los índices beta y alfa entre sí conseguimos columna o fila según se requiera\r\n//             ochouno++\r\n//         }\r\n//     }\r\n\r\n//     return cols\r\n// }\r\n\r\n// function possRows(nueve){\r\n\r\n//     let loop= nueve -1\r\n//     var ochouno= 0\r\n\r\n//     for(let alfa= 0; alfa <= loop; alfa++) {\r\n//         for(let beta= 0; beta <= loop; beta++) {\r\n//             rows[alfa][beta]= qubs[ochouno] \r\n//             ochouno++\r\n//         }\r\n//     }\r\n\r\n//     return rows\r\n// }\r\n\r\n// function possBoxs(){\r\n//     for (let a= 0; a < 81; a++) {\r\n//         updateBox(a)\r\n//     }\r\n//     return boxs\r\n// }\r\n\r\n// function poss(){\r\n//     for (let a= 0; a < 81; a++) {\r\n//         update(a)\r\n//     }\r\n// }\r\n\r\n// function possRandC(boxs){\r\n//     possCols()\r\n//     possRows()\r\n//     boxs= possCols()\r\n//     console.log(boxs)\r\n// }\r\n\r\n// function restore(){\r\n//     for (let a= 0; a < 81; a++) {\r\n//         resetSquare(a)\r\n//     }\r\n// }\r\n\r\n// function updateEvery(){\r\n//     for (let a= 0; a < 81; a++) {\r\n//         update(a)\r\n//     }\r\n// }\r\n\r\n// function megasolution(quantity){\r\n//     let b= []\r\n//     let c=[]\r\n//     let r=[]\r\n//     for (let a= 0; a < 9; a++) {\r\n//         r.push(solution(rows[a], quantity)) \r\n//         c.push(solution(cols[a], quantity)) \r\n//         b.push(solution(boxs[a], quantity)) \r\n//     }\r\n//     let concat= {rows: r, boxs: b, cols: c}\r\n//     return concat\r\n// }\r\n\r\n// function megasolutionBy(entity, quantity){\r\n//     let b= []\r\n//     let c=[]\r\n//     let r=[]\r\n//     let concat\r\n//     for (let a= 0; a < 9; a++) {\r\n//         if(entity==='rows') {r.push(solution(rows[a], quantity)) ; concat= r}\r\n//         if(entity==='cols') {c.push(solution(cols[a], quantity)) ; concat= c}\r\n//         if(entity==='boxs') {b.push(solution(boxs[a], quantity)) ; concat= b}\r\n//     }\r\n//     return concat\r\n// }\r\n\r\n\r\n// function pointerMistakes(entityString, concat, quantity){\r\n    \r\n//     let response= []\r\n//     let e= concat[entityString]\r\n//     for(let a=0; a<e.length; a++){\r\n//         if(e[a]!==-1){\r\n//             response.push({\r\n//                 indice: a,\r\n//                 subindice: e[a]\r\n//             })\r\n//         }\r\n//     }\r\n//     if(quantity> 1){\r\n//         return response\r\n//     }\r\n//     if(!quantity || quantity===1){\r\n//         return [response[0]]\r\n//     }\r\n// }\r\n\r\n// function detectdifficulty(qubs){\r\n//     let cont=[]\r\n//     for(let a=0;a<81;a++){\r\n//         if(qubs[a]!==0){\r\n//             cont.push(a)\r\n//         }\r\n//     }\r\n//     return cont\r\n// }\r\n// function updateEveryCols(){ //Hace un bucle de 81 iteraciones para actualizar las cols respecto a los qubs\r\n//     for(let b=0;b<81;b++) updateCol(b) \r\n// }\r\n\r\n\r\n// function updateQubsBy(what){\r\n//     var q= 0\r\n//     var qubes= []\r\n//     for(let aa= 0; aa < 9; aa++){\r\n//         for(let a= 0; a < 9; a++){\r\n//             if(what===\"rows\") {\r\n//                 qubes.push(rows[aa][a])\r\n//             }\r\n//             if(what===\"cols\") {\r\n//                 qubes.push(cols[a][aa])\r\n//             }\r\n//             if(what===\"boxs\") {\r\n//                 var gross= Math.floor(q / 9) //indica el numero de fila\r\n//                 var index= Math.floor(gross / 3) //este da 0, 1 ó 2\r\n//                 var module= (q % 9)\r\n//                 let indexbox = (Math.floor(q/9)*3 + q%3) %9 //índice puntual -> 0 al 8\r\n//                 var foundbox= Math.floor(module / 3) + index * 3 //índice del box -> 0 al 8\r\n//                 qubes.push(boxs[foundbox][indexbox])\r\n//                 q++\r\n//             }            \r\n//         }\r\n//     }\r\n//     return qubes\r\n// }\r\n\r\n\r\n\r\n// function create3(){\r\n//     var molino= 0\r\n//     var ochouno= 0\r\n//     let setRows= new Set()\r\n//     let setBoxs= new Set()\r\n//     let theSet= new Set() \r\n//     for (let aa= 0; aa < 9; aa++) {\r\n//         for (let a= 0; a < 9; a++) {\r\n//             molino++\r\n//             let random= Math.ceil( Math.random() * 9 ) \r\n//             rows[aa][a]= random\r\n//             // if (a > 0){\r\n//                 if ( solution( rows[aa] ) !== -1 ) {\r\n//                     setRows.add(random)             \r\n//                     if(setRows.size >= 9) {\r\n//                         // rows[aa][a]= 0\r\n//                         // console.log(\"set a 9 en rows\",theSet)\r\n//                         // console.log(setRows, aa, a, random, ochouno, 'rows == 9', rows[aa])     \r\n//                         setBoxs= new Set()\r\n//                         setRows= new Set()\r\n//                         rows[aa]= [0,0,0,  0,0,0,  0,0,0]\r\n//                         qubs= updateQubsBy(\"rows\")\r\n//                         for(let b=0;b<9;b++){\r\n//                             updateBox((aa * 9) +b)\r\n//                             updateCol((aa * 9) +b)\r\n//                         }\r\n//                         ochouno= aa* 9\r\n//                         a= -1\r\n//                         continue\r\n//                     }\r\n//                     // console.log(setRows, aa, a, random, ochouno, 'rows', rows[aa])     \r\n//                     a= a-1\r\n//                     continue\r\n//                 }\r\n//             // }\r\n//             cols[a][aa]= random\r\n//             if (aa > 0){\r\n//                 if ( solution( cols[a] ) !== -1 ) {\r\n//                     setRows.add(random)             \r\n//                     if(setRows.size >= 9) {\r\n//                         // rows[aa][a]= 0\r\n//                         // console.log(\"set a 9 en rows\",theSet)\r\n//                         // console.log(setRows, aa, a, random, ochouno, 'rows == 9', rows[aa])     \r\n//                         setBoxs= new Set()\r\n//                         setRows= new Set()\r\n//                         rows[aa]= [0,0,0,  0,0,0,  0,0,0]\r\n//                         qubs= updateQubsBy(\"rows\")\r\n//                         for(let b=0;b<9;b++){\r\n//                             updateBox((aa * 9) +b)\r\n//                             updateCol((aa * 9) +b)\r\n//                         }\r\n//                         ochouno= aa* 9\r\n//                         a= -1\r\n//                         continue\r\n//                     }\r\n//                     // console.log(setRows, aa, a, random, ochouno, 'rows', rows[aa])     \r\n//                     a= a-1\r\n//                     continue\r\n//                 }\r\n//             }\r\n//                 // console.log(\"pasé los continue\")\r\n//             // }\r\n\r\n//             var q= ochouno\r\n//             var gross= Math.floor(q / 9) //indica el numero de fila\r\n//             var index= Math.floor(gross / 3) //este da 0, 1 ó 2\r\n//             var module= (q % 9)\r\n//             let indexbox = (Math.floor(q/9)*3 + q%3) %9 //índice puntual -> 0 al 8\r\n//             var foundbox= Math.floor(module / 3) + index * 3 //índice del box -> 0 al 8\r\n//             boxs[foundbox][indexbox]= random\r\n            \r\n//             // if( indexbox > 0 ) {\r\n//                 if ( solution( boxs[foundbox] ) !== -1 ) {\r\n//                     setRows.add(random)\r\n//                     boxs[foundbox][indexbox]= 0                     \r\n//                     // console.log(setRows, aa, a, random, ochouno)                    \r\n//                     if(setRows.size >= 9) {\r\n//                         setBoxs= new Set()\r\n//                         setRows= new Set()\r\n//                         rows[aa]= [0,0,0,  0,0,0,  0,0,0]\r\n//                         qubs= updateQubsBy(\"rows\")\r\n//                         for(let b=0;b<9;b++){\r\n//                             updateBox((aa * 9) +b)\r\n//                             updateCol((aa * 9) +b)\r\n//                         }\r\n//                         ochouno= aa* 9\r\n//                         a= -1\r\n//                         // ochouno= aa * 9\r\n//                         continue\r\n//                     }\r\n//                     a=a-1\r\n//                     // ochouno--\r\n//                     continue\r\n//                 }\r\n//             // }\r\n//             if(/*solution(cols[a ])=== -1 &&*/ solution(rows[aa])=== -1){\r\n//                 rows[aa][a]= random\r\n//                 // cols[a][aa]= random\r\n//             }\r\n//             ochouno++\r\n//             setBoxs= new Set()\r\n//             setRows= new Set()\r\n//         }\r\n//         theSet= new Set()\r\n//     }\r\n//     return {ok:\"ok\", molino}\r\n// }\r\n\r\n// function difficult(level) {\r\n//     var coef= level *0.4 +5\r\n\r\n//     var diff= Math.random() * 15 \r\n//     var float= parseFloat(diff.toString().slice(0,3))\r\n\r\n//     if(float > coef) {\r\n//         return true //se busca un numero\r\n//     }\r\n//     return false //no se busca nada\r\n// }\r\n\r\n// function sudoqubs (level, entity){ //SIEMPRE DEBE TOMAR UN INPUT Y SACAR UN OUTPUT\r\n//     var suerte\r\n//     var array = []\r\n//     for (let index = 0; index < 9; index++) { \r\n//         for (let ii = 0; ii < 9; ii++) {\r\n//             suerte= difficult (level)\r\n//             if (!suerte) {\r\n//             entity[index][ii]= 0 \r\n//             array.push(index)\r\n//             }\r\n//         }\r\n//     }\r\n//     return array.length\r\n// } //Rehacer esta function: Seniority()\r\n\r\n// function howmanyQubs(rows){\r\n//     let cont= []\r\n//     for(let a=0; a<rows.length; a++){\r\n//         for(let b=0; b<rows[a].length;b++){\r\n//             if(rows[a][b]!==0){\r\n//                 cont.push(rows[a][b])\r\n//             }\r\n//         }\r\n//     }\r\n//     return cont.length\r\n// }\r\n\r\n// function rows_cols_to_squares(first, second, rowsORcols){\r\n//     function dependsWhom(dominante, calibrador){\r\n//         return dominante*9 +calibrador\r\n//     }\r\n//     if(rowsORcols==='rows'){\r\n//         return dependsWhom(first,second)\r\n//     }\r\n//     if(rowsORcols==='cols'){\r\n//         return dependsWhom(second,first)\r\n//     }\r\n// }\r\n\r\n// function boxs_to_squares(box, index){\r\n//     return Math.floor(index/3)*9 + index % 3 + (box % 3) * 3 + Math.floor(box/3) *3*9\r\n// }\r\n\r\n// function getBoxFromQ(q) {\r\n        \r\n//     var gross= Math.floor(q / 9) //indica el numero de fila\r\n// //calculamos el index vertical\r\n//     var index= Math.floor(gross / 3) //este da 0, 1 ó 2\r\n// //lo usamos para calcular el box exacto al cual pertenecerá\r\n//     var module= (q % 9) \r\n\r\n//     var foundbox= Math.floor(module / 3) + index * 3 //índice del box -> 0 al 8\r\n//     let indexbox = (Math.floor(q/9)*3 + q%3) %9 //índice puntual -> 0 al 8\r\n    \r\n//     // boxs[foundbox][indexbox] = qubs[q]\r\n\r\n//     return [foundbox,indexbox]\r\n\r\n// }\r\n\r\n// poss() // Relaciona las filas, columnas y cajas entre sí\r\n\r\n// restore() // Reinicia el sudoku: borrando los datos de las filas, columnas y cajas\r\n\r\n// let sudoku =create3() // En la variable sudoku se guarda un objeto: {ok: 'ok', molino: number}\r\n\r\n// // create3() genera el sudoku, guardando el rows, cols, y boxs los datos\r\n// // Solo con el Array rows ya podemos desplegar el sudoku en el browser\r\n\r\n// sudoqubs(5, rows) // Esta función es la que borra ciertos números, según cuántos se borran, se define la dificulad\r\n\r\n// qubs= updateQubsBy(\"rows\") // Qubs es un Array de 81 casilleros, con esta función le pasamos los datos de rows a qubs\r\n\r\n// updateEvery() // Relaciona las filas, columnas y cajas entre sí, cada vez que se agregue un número cuando se esté jugando al sudoku, es necesario ejecutar una variante de esta función. \r\n\r\n// export {\r\n//     //Para testing\r\n//     rows, cols, boxs, qubs,\r\n//     updateRow,\r\n//     updateCol,\r\n//     updateBox,\r\n//     //Para update\r\n//     update,\r\n//     //Para reset\r\n//     resetSquare,\r\n//     //Para crear estructura sudoku\r\n//     possCols,\r\n//     possRows,\r\n//     possBoxs,\r\n//     poss,\r\n//     possRandC,\r\n//     restore,\r\n//     detectdifficulty,\r\n//     megasolution,\r\n//     megasolutionBy,\r\n//     create3,\r\n//     updateQubsBy,\r\n//     difficult,\r\n//     //Para crear sudoku lógico:\r\n//     sudoku,\r\n//     //Registro de sudoku:\r\n//     howmanyQubs,\r\n//     //Registro errores:\r\n//     pointerMistakes,\r\n//     //Conversores inversos:\r\n//     boxs_to_squares,\r\n//     rows_cols_to_squares,\r\n//     //conversor regular\r\n//     getBoxFromQ\r\n// }\r\n\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}